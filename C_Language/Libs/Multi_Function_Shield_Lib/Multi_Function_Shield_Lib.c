/*
 * MultiFunction_Shield.c file for Multi_Function_Shield Library
 *
 * Created: 29.07.2018 17:00:00
 * Author : User007
 */ 

#include "MultiFunction_Shield.h"

// Объявляем НЕглобальные переменные и дефайны (глобальные - в MultiFunction_Shield.h)
// Все что в обработчиках прерываний - volatile
// Все что используеться только в 1 функции - static
//-----------------------------------------------------------------------------------------------------------------------------------------------------
// Следующие переменные глобальные, и дополнительно должны быть обьявлены с квалификатором extern в MultiFunction_Shield.h
volatile	uint8_t  mode = 1;								// Заводим глобальную переменную для текущего режима
volatile	uint8_t  digit_counter = 0;						// Установим счетчик разрядов на 1 знакоместо
volatile	uint8_t  adc_result = 0;
volatile	uint16_t temperature_delay = 2000;
volatile	uint16_t led_delay = 500;
volatile	uint8_t  buzzer_delay = 0;
volatile	uint8_t  adc_delay = 0;
volatile	uint8_t  rc5_delay = 0;

#ifdef	USE_INTERRUPT_4_TSOP								// Если используем внешнее прерывание INT0 для получения кода RC5
volatile	uint16_t rc5_code = 0;							// Заводим глобальную переменную для принимаемого кода RC5
#endif

#ifdef	USE_KEY_POLLING_INTERRUPT							// Если используем опрос кнопок в прерывании таймера
volatile	uint8_t  key_delay = 0;							// Опрос кнопок придется производить в прерывании по таймеру (раз в 256 мс)
#endif

uint8_t EEMEM eeprom_mode = 1;                              // Резервная копия режима работы. Вычитывается при кажлдом старте системы

//-----------------------------------------------------------------------------------------------------------------------------------------------------
// Следующие переменные используются исключительно внутри библиотечного модуля, и не должны более нигде обявлятся
volatile	uint8_t  ind_delay = 3;

static const uint8_t digit2segments[] =						// Обьявляем массив символов от 0 до 0x0F
{
	0xC0, // 0
	0xF9, // 1
	0xA4, // 2
	0xB0, // 3
	0x99, // 4
	0x92, // 5
	0x82, // 6
	0xF8, // 7
	0x80, // 8
	0x90, // 9
	0x88, // A
	0x83, // B
	0xC6, // C
	0xA1, // D
	0x86, // E
	0x8E, // F
	0xFF, // blank											// А после дополним массив пустым символом и символами признака ошибки "Err"
	0x86, // E
	0xAF, // r
	0xAF  // r
};

volatile uint8_t value2digits[4] = {0,0,0,0};				// Обьявляем массив катодов индикатора, которые будем перебирать в прерывании таймера

//=====================================================================================================================================================
// Обьявляем прототипы внутримодульных функций
void Write_74HC595(uint8_t byte);							// Запись 1 байта в 74HC595
void Shield_display_digit(uint8_t addr, uint8_t digit);		// Вывод 1 разряда на индикатор
void Shield_display_value(void);							// Вывод значения на индикатор
//=====================================================================================================================================================
// Секция работы с обработчиком прывания по совпадению. Период вызова - 1 мс. При необходимости добавить сюда код, требующий циклического выполнения
//=====================================================================================================================================================
ISR (TIMER1_COMPA_vect)
{
	if (ind_delay != 0) ind_delay--;						// Отсчет времени отображения 1 разряда индикатора
	else
	{
		if (digit_counter < 4)								// Если счетчик разрядов в пределах 4 знакомест
		{
			Shield_display_digit(digit_counter,value2digits[digit_counter]);// Отображаем в текущем разряде необходимый 7-сегментный код
			digit_counter++;								// Выбираем следующий разряд индикатора
		}
		else digit_counter = 0;								// Иначе установим счетчик разрядов на 1 знакоместо
		ind_delay = 3;
	}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
	if (temperature_delay != 0) temperature_delay--;		// Отсчет времени обновления показаний температуры
//-----------------------------------------------------------------------------------------------------------------------------------------------------	
	adc_delay--;											// Отсчет времени обновления показаний АЦП
//-----------------------------------------------------------------------------------------------------------------------------------------------------	
	if (led_delay != 0) led_delay--;						// Отсчет времени мигания светодиодов
	else
	{
		OUTS_PORT_8_13 ^= 1<<LED_4;
		led_delay = 500;
	}
//-----------------------------------------------------------------------------------------------------------------------------------------------------	
	if (buzzer_delay != 0) buzzer_delay--;					// Отсчет времени звучания бузера
	else
	{
		BUZZER_OFF();
	}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
	if (rc5_delay != 0) rc5_delay--;						// Отсчет задержки повторного приема кода RC5
	#ifdef	USE_INTERRUPT_4_TSOP							// Если используем внешнее прерывание INT0 для получения кода RC5
	else
	{
		GIFR = 1<<INTF0;									// Clear External Interrupt Flag 0
		GICR = 1<<INT0;										// External Interrupt Request 0 Enable
	}
	#endif
//-----------------------------------------------------------------------------------------------------------------------------------------------------
	#ifdef	USE_KEY_POLLING_INTERRUPT						// Если используем опрос кнопок в прерывании таймера
	key_delay--;
	if (key_delay == 0) Key_Press();
	#endif
}
//=====================================================================================================================================================
// Секция обработки нажатий кнопок
//=====================================================================================================================================================
void Key_Press(void)										// Опрос кнопок. Может производится как в главном цикле, так и в прерывании таймера
{		
	if (BUTTON_1 == 0)									
	{
		mode--;
		if (mode == 0) mode = NUM_OF_MODES;
		Buzer_Beep(50);
		Switch_Mode();
	}
	else if (BUTTON_3 == 0)
	{		
		mode++;
		if (mode > NUM_OF_MODES) mode = 1;
		Buzer_Beep(50);
		Switch_Mode();
	}
//	if ((mode == 1)||(mode == 2)||(mode == 3)) 
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Switch_Mode(void)										// Выбор действия для нового режима
{
	switch(mode)
	{
		case 1:
		{
			OUTS_PORT_8_13 |= _BV(LED_3)|_BV(LED_2);
			OUTS_PORT_8_13 &= ~_BV(LED_1);
			break;
		}
		case 2:
		{
			OUTS_PORT_8_13 |= _BV(LED_3)|_BV(LED_1);
			OUTS_PORT_8_13 &= ~_BV(LED_2);
			Shield_set_display_value(0);
			break;
		}
		case 3:
		{
			OUTS_PORT_8_13 |= _BV(LED_2)|_BV(LED_1);
			OUTS_PORT_8_13 &= ~_BV(LED_3);
			break;
		}
		default: mode = 1;       
	}
    eeprom_update_byte(&eeprom_mode, mode);                 // Сохраним новый режим работы
}
//=====================================================================================================================================================
// Секция инициализации. Содержит инициализацию базовых возможностей платы расширения MultiFunction_Shield. При необходимости можно дополнить базовую инициализацию
//=====================================================================================================================================================
void Init(void)
{
	OUTS_DDR_0_7 = 1<<BUZZER|1<<SPI_CLK_PIN|1<<SPI_LATCH_PIN;// BUZZER, SPI_CLK_PIN and SPI_LATCH_PIN as output
	OUTS_PORT_0_7 = 1<<BUZZER;								// BUZZER off
	OUTS_DDR_8_13 = 1<<LED_4|1<<LED_3|1<<LED_2|1<<LED_1|1<<SPI_DATA_PIN;// LEDs and SPI_DATA_PIN as outputs
	OUTS_PORT_8_13 = 1<<LED_3|1<<LED_2|1<<LED_1;			// LEDs 1-3 is off
	ANALOG_PORT = _BV(BUTTON_3_PIN)|_BV(BUTTON_2_PIN)|_BV(BUTTON_1_PIN);// Enable pull-ups on Buttons
	UBRRL = LO(bauddivider);								// Инициализация UART
	UBRRH = HI(bauddivider);
	UCSRA = 0;
	UCSRB = 0<<RXCIE|0<<TXCIE|0<<UDRIE|1<<RXEN|1<<TXEN;		// Прерывание UDRIE сразу никогда не разрешаем, иначе контроллер сразу входит в это прерывание
	UCSRC = 1<<URSEL|1<<UCSZ1|1<<UCSZ0;
	// Инициализация Таймеров. Предделитель подбираеться экспериментально, для достижения периода прерывания Timer1 каждую мс
															// Везде вкл. режим прерывания Timer1 по совпадению (1<<WGM12)
	TCCR1B = 1<<WGM12|0<<CS12|0<<CS11|1<<CS10;				// Запуск таймера без предделителя
//	TCCR1B = 1<<WGM12|0<<CS12|1<<CS11|0<<CS10;				// Запуск таймера с предделителем 8
//	TCCR1B = 1<<WGM12|0<<CS12|1<<CS11|1<<CS10;				// Запуск таймера с предделителем 64
//	TCCR1B = 1<<WGM12|1<<CS12|0<<CS11|0<<CS10;				// Запуск таймера с предделителем 256
//	TCCR1B = 1<<WGM12|1<<CS12|0<<CS11|1<<CS10;				// Запуск таймера с предделителем 1024				
	OCR1A = 7999;											// Значение подбираеться экспериментально, для достижения периода прерывания Timer1 каждую мс
	TIMSK = 1<<OCIE1A;										// Разрешаем прерывание по совпадению значения OCR1A с заданым ранее
	TIFR = 1<<OCF1A;										// Сбросим флаг, чтобы прерывание не выскочило сразу
	// Настройка АЦП
	ADMUX = 0<<REFS1|1<<REFS1|1<<ADLAR|0<<MUX3|0<<MUX2|0<<MUX1|0<<MUX0;	// AVCC в качестве ИОН, выравнивание по левому краю (8 старших бит результата), 0 канал АЦП
	ADCSRA = 1<<ADEN|0<<ADSC|0<<ADFR|1<<ADIF|1<<ADIE|0<<ADPS2|0<<ADPS1|0<<ADPS0;// ADC Enable, no start conversion, no ADC Free Running Select, ADC Interrupt enable, ADC Prescaler = 2
	// Настройка энергосбережения и спящего режима
	MCUCR = 1<<SE|0<<SM2|0<<SM1|1<<SM0|1<<ISC01;			// Sleep Enable, Sleep Mode - ADC Noise Reduction, The falling edge of INT0 generates an interrupt request
/*	#ifdef	USE_INTERRUPT_4_TSOP							// Если используем внешнее прерывание INT0 для получения кода RC5 - все равно есть разрешение прерывания в обработчике таймера
	GIFR = 1<<INTF0;										// Clear External Interrupt Flag 0
	GICR = 1<<INT0;											// External Interrupt Request 0 Enable
	#endif */
}
//=====================================================================================================================================================
// Секция работы с индикатором через 2 шт. 74HC595
//=====================================================================================================================================================
void Write_74HC595(uint8_t byte)							// Функция записи 1 байта в 74HC595
{    
	uint8_t i;	
	for (i = 0; i < 8; i++, byte <<= 1)
	{        
		if(byte & 0x80) SPI_DATA_HIGH();		
		else			SPI_DATA_LOW();		
		asm("nop");
		SPI_CLK_HIGH();
		asm("nop");
		SPI_CLK_LOW();  
	}
	asm("nop");
	SPI_LATCH_HIGH(); 
	asm("nop");
	SPI_LATCH_LOW();
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_set_display_value(uint16_t value)				// Функция установки значения для вывода на индикатор
{
	for (uint8_t i = 0; i<4; i++)
	{
		value2digits[i] = 0;								// Обнуляем тысячи, сотни, десятки, и единицы
	}

	while (value >= 1000)									// Вычисляем тысячи
	{
		value -= 1000;
		value2digits[0]++;
	} 	
	while (value >= 100)									// сотни
	{
		value -= 100;
		value2digits[1]++;
	} 
	while (value >= 10)										// десятки
	{
		value -= 10;
		value2digits[2]++;
	} 
	while (value > 0)										// и единицы
	{
		value -= 1;
		value2digits[3]++;
	}
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_display_digit(uint8_t addr, uint8_t digit)		// Функция вывода 1 разряда на индикатор
{
	Write_74HC595(digit < sizeof(digit2segments) ? digit2segments[digit] : 0xFF);// Если входит в диапазон 0-0x0F - отображаем знакоместо, иначе - гасим (лог.1)
	Write_74HC595(1 << addr);								// И зажигаем нужный разряд
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_display_value(void)								// Функция вывода значения на индикатор в основном цикле программы
{
	uint8_t i;
	for (i = 0; i < 4; i++)									// Перебираем все разряды индикатора
	{
		Shield_display_digit(i,value2digits[i]);			// Отображая нужный 7-сегментный код в нужном разряде
		_delay_ms(5);										// Максимально допустимая пауза
	}
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_display_Err(void)								// Вывод признака ошибки на индикатор
{
	for (uint8_t i = 0; i<4; i++)
	{
		value2digits[i] = i+16;
	}
}
//=====================================================================================================================================================
ISR (ADC_vect)												// Прерывания по окончанию преобразования АЦП
{
	adc_result = ADCH;										// Проснулись по окончанию преобразования. Заберем результат преобразования
}
//=====================================================================================================================================================
// Секция обработки кода RC5. В зависимости от директив условной компиляции обработка может осуществляться в обработчике внешнего прерывания INT0, либо поллиингом (периодическим вызовом функции приема)
//=====================================================================================================================================================
#ifdef	USE_INTERRUPT_4_TSOP								// Если используем внешнее прерывание INT0 для получения кода RC5
ISR (INT0_vect)
{
	while (TSOP_PIN == 0);									// Ждем окончания стартового импульса
	_delay_us(START_DELAY);									// Выжидаем первый интервал		
	for (uint8_t i=0; i<CODE_LEN; i++)						// Организуем цикл приема битов кода
	{
		rc5_code <<= 1;										// Сдвигаем код влево 
		if (TSOP_PIN == 0)									// Если на выходе приемника 0,
		rc5_code |= 1;										// это означает прием лог.1
		_delay_us(BIT_DELAY);								// Ждем следующий момент опроса
	}
	GIFR = 1<<INTF0;										// Clear External Interrupt Flag 0
	GICR = 0<<INT0;											// External Interrupt Request 0 Disable
	rc5_delay = 255;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
#else														// Если используем функцию для получения кода RC5
uint16_t Get_RC5_code(void)									
{
	uint16_t code = 0;

	if (TSOP_PIN != 0)										// Только при отсутствии уже начавшегося приема
	{
		while (TSOP_PIN != 0)								// Ждем начала стартового импульса
		{
			if (mode != TSOP_MODE) return code;				// Если режим был изменен, на выход
		}
		while (TSOP_PIN == 0);								// Ждем окончания стартового импульса
		cli();												// Запрещаем прерывания ради точности задержек
		_delay_us(START_DELAY);								// Выжидаем первый интервал
		for (uint8_t i=0; i<CODE_LEN; i++)					// Организуем цикл приема битов кода
		{
			code <<= 1;										// Сдвигаем код влево 
			if (TSOP_PIN == 0)								// Если на выходе приемника 0,
			code |= 1;										// это означает прием лог.1		
			_delay_us(BIT_DELAY);							// Ждем следующий момент опроса
		}
		sei();												// Считывание кода RC5 завершено, разрешаем прерывания
		rc5_delay = 255;
	}
	return code;											// Возвращаем полученный код
}
#endif
//=====================================================================================================================================================
void Buzer_Beep(uint8_t beep_time)							// Вызов звукового сигнала, длительность в мс
{
	BUZZER_ON();
	buzzer_delay = beep_time;
}
//=====================================================================================================================================================
void Send_Byte(uint8_t byte)								// Функция отправки одного байта по UART
{
	while (!(UCSRA & (1<<UDRE))){};							// Ждем флага готовности UART
	UDR = byte;												// Засылаем байт в регистр передатчика
}
//=====================================================================================================================================================	
// Секция работы с шиной 1-wire
//=====================================================================================================================================================	
uint8_t Reset_1_wire(void)									// Функция инициализации обмена (Reset-Presence)
{
	ONE_WIRE_PIN_LOW();										// Опускаем линию в 0
	_delay_us(480);											// Удерживаем линию в низком состоянии на протяжении 480 мкс
	ONE_WIRE_PIN_HIGH();									// Отпускаем линию
	uint8_t i=38;											// Засекаем счетчик на 60 мкс
	for (; i>0; i--)							
	{
		_delay_us(1);											
		if (ONE_WIRE_LINE != 0) break;						// Линия поднялась, продолжаем	
		else if (i==0) return 0;							// Задержка закончена, линия не поднялась - неисправность на линии 
	}
	for (; i>0; i--)										// Продолжаем отсчет 60 мкс
	{
		_delay_us(1);											
		if (ONE_WIRE_LINE == 0) break;						// Сигнал Presence обнаружен
		else if (i==0) return 0;							// Задержка закончена, сигнал Presence не обнаружен
	}	
	_delay_us(55);											// Ждем 55 мкс (Presence>=60)
	if (ONE_WIRE_LINE != 0) return 0;						// Проверяем линию. Если опущена - можем продолжать
	for (i=118; i>0; i--)									// Засекаем счетчик на 190 мкс
	{
		_delay_us(1);											
		if (ONE_WIRE_LINE != 0) break;						// Линия поднялась - фиксируем конец Presence 						
		else if (i==0) return 0;							// Задержка закончена, линия не поднялась, неисправность на линии
	}
	return 1;												// Полученный ответ соответствует временным рамкам
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Send_1_wire_byte(uint8_t byte)							// Отправка 1 байта по шине 1-wire
{
	for (uint8_t i=0; i<8; i++)								// Организуем цикл отправки 1 байта
	{
		if((byte & (1<<i)) == 1<<i)							// Send 1
		{
			ONE_WIRE_PIN_LOW();								// Опускаем линию в 0
			_delay_us(1);		
			ONE_WIRE_PIN_HIGH();							// Отпускаем линию
			_delay_us(60);									// Ждем 60 мкс	
		}
		else												// Send 0
		{
			ONE_WIRE_PIN_LOW();								// Опускаем линию в 0		
			_delay_us(60);									// Ждем 60 мкс
			ONE_WIRE_PIN_HIGH();							// Отпускаем линию
			_delay_us(1);
		}
	}
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
uint8_t One_wire_receive_byte(void)							// Прием 1 байта по шине 1-wire
{	
	uint8_t one_wire_byte = 0;
	for (uint8_t i=0; i<8; i++)								// Организуем цикл отправки 1 байта
	{
		ONE_WIRE_PIN_LOW();									// Опускаем линию в 0		
		_delay_us(1);
		ONE_WIRE_PIN_HIGH();								// Отпускаем линию
		_delay_us(12);										// Ждем 12 мкс
		if (ONE_WIRE_LINE == 0)
			one_wire_byte &=~(1<<i);
		else one_wire_byte |= 1<<i;
		_delay_us(47);										// Ждем 47 мкс (60-12-1) до конца тайм-слота
	}
	return one_wire_byte;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
uint8_t Read_Temperature(void)								// Чтение температуры
{
	uint8_t temperature = 0;
	temperature = One_wire_receive_byte()>>4;				// Читаем младший байт температуры, перемещая целую часть в младшую тетраду
	return (temperature | (One_wire_receive_byte() << 4));	// Читаем старший байт температуры, перемещая значащую часть в старшую тетраду, совмещаем тетрады 2 принятых байт, и возвращаем результат
}
//=====================================================================================================================================================	
