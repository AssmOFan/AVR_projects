/*
 * MultiFunction_Shield.c file for Multi_Function_Shield Library
 *
 * Created: 29.07.2018 17:00:00
 * Author : User007
 */ 

#include "MultiFunction_Shield.h"
#include "tick.h"

// Объявляем НЕглобальные переменные и дефайны (глобальные - в MultiFunction_Shield.h)
// Все что в обработчиках прерываний - volatile
// Переменные, которые должны сохранять свое состояние между вызовами функции - static

//-----------------------------------------------------------------------------------------------------------------------------------------------------
// Следующие переменные глобальные, и дополнительно должны быть обьявлены с квалификатором extern в MultiFunction_Shield.h

uint8_t  mode = 1;
uint16_t buzzer_delay = 0;
uint16_t adc_delay = 0;
uint16_t rc5_delay = 0;
uint16_t temperature_delay = 0;
volatile uint8_t adc_result = 0;

#ifdef	USE_INTERRUPT_4_TSOP								// Если используем внешнее прерывание INT0 для получения кода RC5
volatile    uint16_t rc5_code = 0;							// Заводим глобальную переменную для принимаемого кода RC5
#endif

//-----------------------------------------------------------------------------------------------------------------------------------------------------
// Следующие переменные используются исключительно внутри библиотечного модуля, и не должны более нигде обявлятся

static const uint8_t digit2segments[] =						// Обьявляем массив символов от 0 до 0x0F
{
	0xC0, // 0
	0xF9, // 1
	0xA4, // 2
	0xB0, // 3
	0x99, // 4
	0x92, // 5
	0x82, // 6
	0xF8, // 7
	0x80, // 8
	0x90, // 9
	0x88, // A
	0x83, // B
	0xC6, // C
	0xA1, // D
	0x86, // E
	0x8E, // F
	0xFF, // blank											// И дополним массив пустым символом и символами ошибки "Err"
	0x86, // E
	0xAF, // r
	0xAF  // r
};

volatile uint8_t value2digits[4] = {0,0,0,0};				// Обьявляем массив катодов индикатора, которые будем перебирать для индикации всего значения

//=====================================================================================================================================================
// Обьявляем прототипы внутримодульных функций
void Write_74HC595(uint8_t byte);							// Запись 1 байта в 74HC595
void Shield_display_digit(uint8_t addr, uint8_t digit);		// Вывод 1 разряда на индикатор
void Shield_display_value(void);							// Вывод значения на индикатор
//=====================================================================================================================================================
// Секция обработки нажатий кнопок
//=====================================================================================================================================================
void Switch_Mode(void)										// Выбор действия для нового режима
{
	switch(mode)
	{
		case 1:
		{
			OUTS_PORT_8_13 |= _BV(LED_3)|_BV(LED_2);
			OUTS_PORT_8_13 &= ~_BV(LED_1);
            adc_delay = t_ms;
			break;
		}
		case 2:
		{
			OUTS_PORT_8_13 |= _BV(LED_3)|_BV(LED_1);
			OUTS_PORT_8_13 &= ~_BV(LED_2);			
            rc5_delay = t_ms;
            Shield_set_display_value(0);
			break;
		}
		case 3:
		{
			OUTS_PORT_8_13 |= _BV(LED_2)|_BV(LED_1);
			OUTS_PORT_8_13 &= ~_BV(LED_3);
            temperature_delay = t_ms;
			break;
		}
		default: mode = 1;       
	}
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Key_Press(void)										// Опрос кнопок
{		
    static int16_t key_delay = 0;

    if (t_ms - key_delay + 0xFF00 >= 0xFF00)
    {
    	if (BUTTON_1 == 0)									
    	{
    		mode--;
    		if (mode == 0) mode = NUM_OF_MODES;
    		Buzer_Beep(SHORT_BEEP);
    		Switch_Mode();
			key_delay += 200;
    	}
    	else if (BUTTON_2 == 0)
    	{		
            
    	}
    	else if (BUTTON_3 == 0)
    	{		
    		mode++;
    		if (mode > NUM_OF_MODES) mode = 1;
    		Buzer_Beep(SHORT_BEEP);
    		Switch_Mode();
			key_delay += 200;
    	}

		else key_delay += 50;                               // если нет нажатых кнопок следующий опрос через 50 мс
    }
}
//=====================================================================================================================================================
// Секция инициализации. Содержит инициализацию базовых возможностей платы расширения MultiFunction_Shield. При необходимости можно дополнить базовую инициализацию
//=====================================================================================================================================================
void Init_Multi_Function_Shield(void)
{
// Инициализация портов
	OUTS_DDR_0_7 = 1<<BUZZER|1<<SPI_CLK_PIN|1<<SPI_LATCH_PIN;// BUZZER, SPI_CLK_PIN and SPI_LATCH_PIN as output
	OUTS_PORT_0_7 = 1<<BUZZER;								// BUZZER off
	OUTS_DDR_8_13 = 1<<LED_4|1<<LED_3|1<<LED_2|1<<LED_1|1<<SPI_DATA_PIN;// LEDs and SPI_DATA_PIN as outputs
	OUTS_PORT_8_13 = 1<<LED_3|1<<LED_2|1<<LED_1;			// LEDs 1-3 is off
	ANALOG_PORT = _BV(BUTTON_3_PIN)|_BV(BUTTON_2_PIN)|_BV(BUTTON_1_PIN);// Enable pull-ups on Buttons
// Инициализация UART
//-----------------------------------------------------------------------------------------------------------------------------------------------------
	UBRRL = LO(bauddivider);								
	UBRRH = HI(bauddivider);
	UCSRA = 0;
	UCSRB = 0<<RXCIE|0<<TXCIE|0<<UDRIE|1<<RXEN|1<<TXEN;		// Прерывание UDRIE сразу никогда не разрешаем, иначе контроллер сразу входит в это прерывание
	UCSRC = 1<<URSEL|1<<UCSZ1|1<<UCSZ0;
// Настройка АЦП
//-----------------------------------------------------------------------------------------------------------------------------------------------------
	ADMUX = 0<<REFS1|1<<REFS1|1<<ADLAR|0<<MUX3|0<<MUX2|0<<MUX1|0<<MUX0;	// AVCC в качестве ИОН, выравнивание по левому краю (8 старших бит результата), 0 канал АЦП
	ADCSRA = 1<<ADEN|0<<ADSC|0<<ADFR|1<<ADIF|1<<ADIE|0<<ADPS2|0<<ADPS1|0<<ADPS0;// ADC Enable, no start conversion, no ADC Free Running Select, ADC Interrupt enable, ADC Prescaler = 2
// Настройка энергосбережения и спящего режима
//-----------------------------------------------------------------------------------------------------------------------------------------------------
	MCUCR = 1<<SE|0<<SM2|0<<SM1|1<<SM0|1<<ISC01;			// Sleep Enable, Sleep Mode - ADC Noise Reduction, The falling edge of INT0 generates an interrupt request
//-----------------------------------------------------------------------------------------------------------------------------------------------------
/*	#ifdef	USE_INTERRUPT_4_TSOP							// Если используем внешнее прерывание INT0 для получения кода RC5 - все равно есть разрешение прерывания по таймеру
	GIFR = 1<<INTF0;										// Clear External Interrupt Flag 0
	GICR = 1<<INT0;											// External Interrupt Request 0 Enable
	#endif */
}
//=====================================================================================================================================================
// Секция работы с индикатором через 74HC595 (2 шт, соединенные последовательно)
//=====================================================================================================================================================
void Write_74HC595(uint8_t byte)							// запись 1 байта в 74HC595
{    
	for (uint8_t i = 0; i < 8; i++, byte <<= 1)
	{        
		if(byte & 0x80) SPI_DATA_HIGH();		
		else			SPI_DATA_LOW();		
		asm("nop");
		SPI_CLK_HIGH();
		asm("nop");
		SPI_CLK_LOW();  
	}
	asm("nop");
	SPI_LATCH_HIGH(); 
	asm("nop");
	SPI_LATCH_LOW();
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_set_display_value(uint16_t value)				// установка значения для вывода на индикатор
{
	for (uint8_t i = 0; i<4; i++)
	{
		value2digits[i] = 0;								// Обнуляем тысячи, сотни, десятки, и единицы
	}

	while (value >= 1000)									// Вычисляем тысячи
	{
		value -= 1000;
		value2digits[0]++;
	} 	
	while (value >= 100)									// сотни
	{
		value -= 100;
		value2digits[1]++;
	} 
	while (value >= 10)										// десятки
	{
		value -= 10;
		value2digits[2]++;
	} 
	while (value > 0)										// и единицы
	{
		value -= 1;
		value2digits[3]++;
	}
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_display_digit(uint8_t addr, uint8_t digit)		// вывод 1 разряда на индикатор
{
	Write_74HC595(digit < sizeof(digit2segments) ? digit2segments[digit] : 0xFF);// Если входит в диапазон 0-0x0F - отображаем знакоместо, иначе - гасим (лог.1)
	Write_74HC595(1 << addr);								// И зажигаем нужный разряд
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_display_value(void)								// вывод значения на индикатор
{
	static uint8_t i = 0;									// Переменные, объвленные как static не исчезают после выхода из функции, и сохраняют свое значение
    static int16_t display_delay = 0;

    if ((int16_t)(t_ms - display_delay) >= 0)               // Если пришло время отобразить очередной разряд индикатора
    {
        Shield_display_digit(i,value2digits[i]);		    // Отображаем нужный 7-сегментный код в нужном разряде
        i++;                                                // Выбираем следующий разряд индикатора
        i &= 0x03;											// Не даем "i" стать больше 3, зануляя старшые разряды (цикл выглядит как 0-1-2-3)
		display_delay += 5;                                 // Установим задержку 5ms до следующей смены разряда (частота обновления 1 разряда составит 50 Гц)       
    }
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Shield_display_Err(void)								// вывод символов ошибки на индикатор
{
	for (uint8_t i = 0; i<4; i++)
	{
		value2digits[i] = i+16;                             // добавляем смещение для каждого символа ошибки
	}
}
//=====================================================================================================================================================
ISR (ADC_vect)												// прерывания по окончанию преобразования АЦП
{
	adc_result = ADCH;										// проснулись по окончанию преобразования. Заберем результат преобразования
}
//=====================================================================================================================================================
// Секция обработки кода RC5. В зависимости от директив условной компиляции обработка может осуществляться в обработчике внешнего прерывания INT0, либо поллиингом (периодическим вызовом функции приема)
//=====================================================================================================================================================
#ifdef	USE_INTERRUPT_4_TSOP								// Если используем внешнее прерывание INT0 для получения кода RC5
ISR (INT0_vect)
{
	while (TSOP_PIN == 0);									// Ждем окончания стартового импульса
	_delay_us(START_DELAY);									// Выжидаем первый интервал		
	for (uint8_t i=0; i<CODE_LEN; i++)						// Организуем цикл приема битов кода
	{
		rc5_code <<= 1;										// Сдвигаем код влево 
		if (TSOP_PIN == 0)									// Если на выходе приемника 0,
		rc5_code |= 1;										// это означает прием лог.1
		_delay_us(BIT_DELAY);								// Ждем следующий момент опроса
	}
	GIFR = 1<<INTF0;										// Clear External Interrupt Flag 0
	GICR = 0<<INT0;											// External Interrupt Request 0 Disable
	rc5_delay = t_ms + 250;                                 // обновим задержку до следующего разрешения внешнего прерывания
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
#else														// Если используем функцию для получения кода RC5
uint16_t Get_RC5_code(void)									
{
	uint16_t code = 0;

	if (TSOP_PIN != 0)										// Только при отсутствии уже начавшегося приема
	{
		while (TSOP_PIN != 0)								// Ждем начала стартового импульса
		{          
            t0_update();
            Blink_Led_4();
            Shield_display_value();						    // Вывод значения на индикатор
            Buzer_OFF();
            Key_Press();
			if (mode != TSOP_MODE) return code;				// Если режим был изменен, на выход
		}
		while (TSOP_PIN == 0);								// Ждем окончания стартового импульса
		cli();												// Запрещаем прерывания ради точности задержек
		_delay_us(START_DELAY);								// Выжидаем первый интервал
		for (uint8_t i=0; i<CODE_LEN; i++)					// Организуем цикл приема битов кода
		{
			code <<= 1;										// Сдвигаем код влево 
			if (TSOP_PIN == 0)								// Если на выходе приемника 0,
			code |= 1;										// это означает прием лог.1		
			_delay_us(BIT_DELAY);							// Ждем следующий момент опроса
		}
		sei();												// Считывание кода RC5 завершено, разрешаем прерывания
		rc5_delay = t_ms + 250;                             // обновим задержку до следующего разрешения внешнего прерывания
	}
	return code;											// Возвращаем полученный код
}
#endif
//=====================================================================================================================================================
void Buzer_Beep(beep_delay)									// звуковой сигнал длительность X мс
{
	BUZZER_ON();
	buzzer_delay = t_ms + beep_delay;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Buzer_OFF(void)                                        // выключение звукового сигнала
{
    if ((BUZZER_IS_ON) && (t_ms - buzzer_delay + 0xFF00 >= 0xFF00))
    {
        BUZZER_OFF();
    }
}
//=====================================================================================================================================================
void Send_Byte(uint8_t byte)								// отправка одного байта по UART
{
	while (!(UCSRA & (1<<UDRE))){};							// ждем флага готовности UART
	UDR = byte;												// засылаем байт в регистр передатчика
}
//=====================================================================================================================================================	
// Секция работы с шиной 1-wire
//=====================================================================================================================================================	
uint8_t Reset_1_wire(void)									// инициализации обмена по шине 1-wire (Reset-Presence)
{
	ONE_WIRE_PIN_LOW();										// Опускаем линию в 0
	_delay_us(480);											// Удерживаем линию в низком состоянии на протяжении 480 мкс
	ONE_WIRE_PIN_HIGH();									// Отпускаем линию
	uint8_t i=38;											// Засекаем счетчик на 60 мкс
	for (; i>0; i--)							
	{
		_delay_us(1);											
		if (ONE_WIRE_LINE != 0) break;						// Линия поднялась, продолжаем	
		else if (i==0) return 0;							// Задержка закончена, линия не поднялась - неисправность на линии 
	}
	for (; i>0; i--)										// Продолжаем отсчет счетчика 60 мкс
	{
		_delay_us(1);											
		if (ONE_WIRE_LINE == 0) break;						// Сигнал Presence обнаружен
		else if (i==0) return 0;							// Задержка закончена, сигнал Presence не обнаружен
	}	
	_delay_us(55);											// Ждем 55 мкс (Presence>=60)
	if (ONE_WIRE_LINE != 0) return 0;						// Проверяем линию. Если опущена - можем продолжать
	for (i=118; i>0; i--)									// Засекаем счетчик на 190 мкс
	{
		_delay_us(1);											
		if (ONE_WIRE_LINE != 0) break;						// Линия поднялась - фиксируем конец Presence 						
		else if (i==0) return 0;							// Задержка закончена, линия не поднялась, неисправность на линии
	}
	return 1;												// Полученный ответ соответствует временным рамкам
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void Send_1_wire_byte(uint8_t byte)							// отправка 1 байта по шине 1-wire
{
	for (uint8_t i=0; i<8; i++)								// Организуем цикл отправки 1 байта
	{
		if((byte & (1<<i)) == 1<<i)							// Send 1
		{
			ONE_WIRE_PIN_LOW();								// Опускаем линию в 0
			_delay_us(1);		
			ONE_WIRE_PIN_HIGH();							// Отпускаем линию
			_delay_us(60);									// Ждем 60us	
		}
		else												// Send 0
		{
			ONE_WIRE_PIN_LOW();								// Опускаем линию в 0		
			_delay_us(60);									// Ждем 60us
			ONE_WIRE_PIN_HIGH();							// Отпускаем линию
			_delay_us(1);
		}
	}
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
uint8_t One_wire_receive_byte(void)							// прием 1 байта по шине 1-wire
{	
	uint8_t one_wire_byte = 0;
	for (uint8_t i=0; i<8; i++)								// Организуем цикл отправки 1 байта
	{
		ONE_WIRE_PIN_LOW();									// Опускаем линию в 0		
		_delay_us(1);
		ONE_WIRE_PIN_HIGH();								// Отпускаем линию
		_delay_us(12);										// Ждем 12us
		if (ONE_WIRE_LINE == 0)
			one_wire_byte &=~(1<<i);
		else one_wire_byte |= 1<<i;
		_delay_us(47);										// Ждем 47us до конца тайм-слота (60us)
	}
	return one_wire_byte;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
uint8_t Read_Temperature(void)								// чтение температуры (только целая часть, без CRC)
{
	uint8_t temperature = 0;
	temperature = One_wire_receive_byte()>>4;				// Читаем младший байт температуры, перемещая целую часть в младшую тетраду
	return (temperature | (One_wire_receive_byte() << 4));	// Читаем старший байт температуры, перемещая значащую часть в старшую тетраду, совмещаем тетрады 2 принятых байт, и возвращаем результат
}
//=====================================================================================================================================================
