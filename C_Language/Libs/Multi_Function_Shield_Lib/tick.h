// tick.h
#pragma once
#include <stdint.h>
//=====================================================================================================================================================
// При тактовой частоте 16 МГц и прескалере таймера 256, получается разрешение тика в 16 мкс и полный цикл в 1 секунду
// При прескалере 1024 — 64 мкс и 4 секунды.
// При тактовой частоте 8 МГц и прескалере таймера 256, получается разрешение тика в 8 мкс и полный цикл в 500 мс
// При прескалере 1024 — 32 мкс и 2 секунды.
#define T0_PRESC                (1<<CS02)
#define T0_FREQ                 (F_CPU / 256.0)
#define T0_US(n)                (uint16_t)(1e-6 * (n) * T0_FREQ + 0.5)
#define T0_MS(n)                (uint16_t)(1e-3 * (n) * T0_FREQ + 0.5)
#define T0_SEC(n)               (uint16_t)(1.0  * (n) * T0_FREQ + 0.5)
//=====================================================================================================================================================
extern uint16_t t0_ctr;
//=====================================================================================================================================================
// Добавлено для организации вторичных счётчиков времени в миллисекундах и секундах
extern uint16_t t_ms;           // max = 65,5  s
extern uint32_t t_sec32;        // max = 136 years
#define t_sec (uint16_t)t_sec32 // max = 18  hours
//=====================================================================================================================================================
void t0_update();               // обновляем значение полного счётчика тиков (вызываем 1 раз в начале главного цикла программы)
void t0_init();                 // запуск таймера
//=====================================================================================================================================================
// Пример проверки задержки диапазоном 0-128 (используется только половина диапазона uint8_t,
// зато если пропустим момент окончания задержки, в запасе для проверки остется вторая половина диапазона)
// if ((int8_t)(t0_ctr - delay) >= 0) - проверяем счетчик тиков (задержка устанавливается с помощью макросов)
//-----------------------------------------------------------------------------------------------------------------------------------------------------
// Пример проверки задержки диапазоном 0-32768 (используется только половина диапазона uint16_t,
// зато если пропустим момент окончания задержки, в запасе остется вторая половина диапазона)
// if ((int16_t)(t0_ctr - delay) >= 0) - проверяем счетчик тиков (задержка устанавливается с помощью макросов)
// if ((int16_t)(t_ms - delay) >= 0) - проверяем счетчик миллисекунд (задержка устанавливается в мс)
//=====================================================================================================================================================
// Пример проверки задержки диапазоном 0-240 (используется большая часть диапазона uint8_t,
// зато если пропустим момент окончания задержки, в запасе для проверки остется всего 16 тиков/ms после окончания задержки)
// if((uint8_t)(t0_ctr - delay + 240) >= 240) - проверяем счетчик тиков (задержка устанавливается с помощью макросов)
//-----------------------------------------------------------------------------------------------------------------------------------------------------
// Пример проверки задержки диапазоном 0-65280 (используется большая часть диапазона uint16_t,
// зато если пропустим момент окончания задержки, в запасе для проверки остется всего 256 тиков/ms после окончания задержки)
// if (t0_ctr - delay + 0xFF00 >= 0xFF00) - проверяем счетчик тиков (задержка устанавливается с помощью макросов)
// if (t_ms - delay + 0xFF00 >= 0xFF00) - проверяем счетчик миллисекунд (задержка устанавливается в мс) // Если разрядность данных меньше разрядности int, то нужно приводить. В арме int — 32 бита.
//=====================================================================================================================================================
