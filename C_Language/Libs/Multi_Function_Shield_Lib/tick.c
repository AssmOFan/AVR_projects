// tick.c
#include <avr/io.h>
#include <avr/interrupt.h>
#include "tick.h"
//=====================================================================================================================================================
uint16_t t0_ctr;                    // расширенный счётчик тиков
//-----------------------------------------------------------------------------------------------------------------------------------------------------
static volatile uint8_t ovf_ctr;    // считаем переполнения

ISR(TIMER0_OVF_vect)
{
    ovf_ctr++;
}
//=====================================================================================================================================================
void t0_init()                      // запуск таймера
{
    TCCR0 = T0_PRESC;               // запустить счёт
    TIMSK |= 1<<TOIE0;              // разрешить прерывание по переполнению
}
//=====================================================================================================================================================
/*                                  // вариант обновления счетчика без дополнительных вторичных счётчиков времени в миллисекундах и секундах
void t0_update()                    // обновляем значение полного счётчика тиков (вызываем 1 раз в начале главного цикла программы)
{                                   // младшая часть значения получается из аппаратного счётчика, старшая — из посчитанного количества переполнений
    uint8_t ctr_high, ctr_low;
    do
    {
        ctr_high = ovf_ctr;
        ctr_low = TCNT0;
    }
    while ((TIFR & (1<<TOV0)) || (ovf_ctr != ctr_high));// проверка изминения счетчика переполнения однобайтного таймера
    //while((TIFR & (1<<TOV1)) || ((uint8_t)ovf_ctr != (uint8_t)ctr_high));// проверка изминения счетчика переполнения двухбайтного таймера
    t0_ctr = ctr_low | (ctr_high << 8);
}
*/
//=====================================================================================================================================================
// Добавлено для организации вторичных счётчиков времени в миллисекундах и секундах
uint16_t t_ms;
uint32_t t_sec32;

void t0_update()
{
    static uint16_t last_ms, last_sec;   
//  обновляем t0_ctr
//-----------------------------------------------------------------------------------------------------------------------------------------------------
    uint8_t ctr_high, ctr_low;
    do
    {
        ctr_high = ovf_ctr;
        ctr_low = TCNT0;
    }
    while ((TIFR & (1<<TOV0)) || (ovf_ctr != ctr_high));// проверка изминения счетчика переполнения однобайтного таймера
    //while((TIFR & (1<<TOV1)) || ((uint8_t)ovf_ctr != (uint8_t)ctr_high));// проверка изминения счетчика переполнения двухбайтного таймера
    t0_ctr = ctr_low | (ctr_high << 8);
//-----------------------------------------------------------------------------------------------------------------------------------------------------
    while(t0_ctr - last_ms >= T0_MS(1))
    {
        t_ms++;
        last_ms += T0_MS(1);

        if(t_ms - last_sec >= 1000)
        {
            t_sec32++;
            last_sec += 1000;
        }
    }
}
//=====================================================================================================================================================
