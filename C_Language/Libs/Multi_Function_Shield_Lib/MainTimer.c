#include "MainTimer.h"
#include "MultiFunction_Shield.h"
//=====================================================================================================================================================
static volatile MAIN_TIMER_BITS time_ms = 0;                    // Переменные, объвленные как static не исчезают после выхода из функции, и сохраняют свое значение
//=====================================================================================================================================================
/*
#if defined (__AVR_ATtiny26__) || (__AVR_ATmega8__)             // Ћпределим обработчик системного таймера согласно выбраного контроллера
ISR (TIMER0_OVF_vect)

#elif defined (__AVR_ATmega8535__) || (__AVR_ATmega16__) || (__AVR_ATmega16A__) || (__AVR_ATmega32__)
ISR (TIMER0_COMP_vect)

#else
ISR (TIMER0_COMPA_vect)
#endif
{                                                               // Обработчик прерывания системного таймера
    #if defined (__AVR_ATtiny26__) || (__AVR_ATmega8__)
    TCNT0 = 131;                                                // Load value for overflow in 1ms
    #endif
	time_ms++;									                // Увеличиваем переменную времени
}
*/
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void SysTick_Config(void)                                       // Настраиваем Timer0 в качестве системного - на прерывание каждую мс
{
    #if defined (__AVR_ATtiny26__) || (__AVR_ATmega8__)         // Настройка производитсЯ согласно выбраного контроллера 
    TCCR0 = 0<<CS02|1<<CS01|1<<CS00;                            // Prescaler = CK/64
    TCNT0 = 131;                                                // Load value for overflow in 1ms
    TIFR = 1<<TOV0;                                             // Clear Timer/Counter0 Overflow Flag 
    TIMSK = 1<<TOIE0;                                           // Timer/Counter0 Overflow Interrupt Enable

    #elif defined (__AVR_ATmega8535__) || (__AVR_ATmega16__) || (__AVR_ATmega16A__) || (__AVR_ATmega32__)
    TCCR0 = 1<<WGM01|0<<CS02|1<<CS01|1<<CS00                    // Mode2 - CTC enable (1<<WGM01), Prescaler = CK/64
    OCR0 = 124;                                                 // Значение подбираеться экспериментально, для достижения периода прерывания Timer0 каждую мс
    TIFR = 1<<OCF0;                                             // Clear Output Compare Flag 0    
    TIMSK = 1<<OCIE0;                                           // Timer/Counter0 Output Compare Match Interrupt Enable      

    #else
    TCCR0A = 1<<WGM01;										    // Mode2 - CTC enable (1<<WGM01)
    TCCR0B = 0<<CS02|1<<CS01|1<<CS00;	                        // Prescaler = CK/64
    OCR0A = 124;									            // Значение подбираеться экспериментально, для достижения периода прерывания Timer0 каждую мс
    TIFR = 1<<OCF0A;								            // Clear Output Compare Flag 0 A
    TIMSK = 1<<OCIE0A;								            // Timer/Counter0 Output Compare Match A Interrupt Enable
    #endif
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
void MainTimerInit(void)                                        // Инициализация таймера
{
	time_ms = 0;								                // Обнуляем переменную времени
	SysTick_Config();		                                    // Запускаем аппаратный таймер
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
MAIN_TIMER_BITS MainTimerSet(MAIN_TIMER_BITS add_time_ms)       // Остановка таймера
{
    return(time_ms + add_time_ms);
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
MAIN_TIMER_BITS MainTimerIsExpired(MAIN_TIMER_BITS delay)       // Проверка таймера
{
    return (MAIN_TIMER_BITS)(time_ms - delay);
//  Операция "(MAIN_TIMER_BITS)(time_ms - delay)" вернет количество ms, прошедших с момента установки delay
//  Если этот момент еще в будущем, то результат отрицательный, если уже в прошлом - положительный
//  Главное, чтобы этот результат вписывался в диапазон MAIN_TIMER_BITS от -32767 до 32768
//  Следовательно, максимальная задержка 32768 ms для int16_t. Остальная часть диапазона - запас, в течении которого нужно успеть обработать событие
}
//=====================================================================================================================================================
