/*
 * Example Main.c file for Multi_Function_Shield Library
 *
 * Created: 29.07.2018 17:00:00
 * Author : User007
 */ 

//#include <avr/io.h>
//#include <util/delay.h>
//#include <avr/interrupt.h>
#include <avr/eeprom.h>
//#include <util/atomic.h>
//#include <avr/pgmspace.h>

#include "MultiFunction_Shield.h"
#include "tick.h"

//=====================================================================================================================================================
// Объявляем глобальные переменные и дефайны
// Все что в обработчиках прерываний - volatile
// Все что используеться только в 1 функции - static

uint8_t EEMEM eeprom_mode = 1;                                  // резервная копия режима работы. Вычитывается при каждом старте системы
//=====================================================================================================================================================
// Обьявляем прототипы функций

void Blink_Led_4(void);
void Switch_Shield_Mode(void);
//=====================================================================================================================================================
int main(void)
{
	Init_Multi_Function_Shield();								// инициализация портов и периферии Multi Function Shield
    t0_init();                                                  // инициализация таймерной службы 
        
//    mode = 1;
	mode = eeprom_read_byte(&eeprom_mode);                      // восстанавливаем из памяти предыдущий режим работы
    uint8_t old_mode = mode;
	Switch_Mode();                                              // и зажигаем соответствующий индикатор

    sei();
 
//	Главный цикл =======================================================================================================================================
	while (1)
	{
        t0_update();                                            // обновляем значение полного счётчика тиков
        Blink_Led_4();                                          // мигаем светодиодом
        Key_Press();                                            // опрашиваем кнопки
        if (mode != old_mode)                                   // если режим изменился
        {
            old_mode = mode;                                    // обновим предыдущий режим
            eeprom_update_byte(&eeprom_mode, mode);             // сохраним новый режим работы
        }
        Switch_Shield_Mode();                                   // устанавливаем значение для вывода на индикатор согласно текущего режима работы
        Shield_display_value();								    // вывод значения на индикатор
        Buzer_OFF();                                            // выключаем динамик, если о включен, а время звучания окончено
    }
}
//======================================================================================================================================================
void Switch_Shield_Mode(void)                                   // конечный автомат установки значения для вывода на индикатор согласно текущего режима работы
{        
	switch(mode)
	{
		case 1:                                                 // режим отображения 0 канала АЦП
		{		    																	 
			if (t_ms - adc_delay + 0xFF00 >= 0xFF00)            // если пришло время обновить показания АЦП	
            {	
				asm("sleep");								    // sleep and start new conversion
				Shield_set_display_value(adc_result);		    // set new ADC result for indication
				adc_delay += 500;						        // set new conversion delay
			}
			break;
		}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
		case 2:                                                 // режим отображения принятого кода RC5
		{       
            #ifdef	USE_INTERRUPT_4_TSOP					    // если используем внешнее прерывание INT0 для получения кода RC5
            if (t_ms - rc5_delay + 0xFF00 >= 0xFF00)            // если пришло время разрешить внешнее прервание					
            {               
                GIFR = 1<<INTF0;								// clear External Interrupt Flag 0
	            GICR = 1<<INT0;									// external Interrupt Request 0 Enable
				rc5_delay += 250;                               // установим задержку до следующего разрешения внешнего прерывания
            }					    			
			#else                                               // если не используем внешнее прерывание INT0 для получения кода RC5            			
            uint16_t rc5_code = 0;                              // заводим переменную для приема кода RC5                              
            if (t_ms - rc5_delay + 0xFF00 >= 0xFF00)            // если нет запрета на повторное считывания кода RC5
            {                               
                rc5_code = Get_RC5_code();                      // используем функцию для получения кода RC5	
            }
            #endif
								
			if (rc5_code != 0)                                  // если есть новый считаный код
			{
				Shield_set_display_value(rc5_code & 0x07FF);    // выводим на индикатор, маскируя 2-й стартовый бит и toggle-бит
				Send_Byte((rc5_code>>8) & 0x07);			    // выводим в UART, маскируя 2-й стартовый бит и toggle-бит
				Send_Byte(rc5_code);
				rc5_code = 0;
				Buzer_Beep(SHORT_BEEP);
				rc5_delay += 250;                               // установим задержку до следующего разрешения повторного считывания кода RC5
			}
			break;
		}
//-----------------------------------------------------------------------------------------------------------------------------------------------------
		case 3:                                                 // режим отображения тепературы с датчика DS18B20
		{     
			if (t_ms - temperature_delay + 0xFF00 >= 0xFF00)    // если пришло время обновить показания температуры/считать преобразованое значение
            {
			    static uint8_t ds18b20_state = 0;
            	uint8_t one_wire_state = 0;
                				
				if (ds18b20_state == 0)                         // если это фаза отправки команды на начало преобразования
				{							
					one_wire_state = Reset_1_wire();		    // инициализация обмена (Reset-Presence)			
					if (one_wire_state == 1)                    // если датчик живой
					{
						Send_1_wire_byte(SKIP_ROM);				// пропускаем чтение адреса
						Send_1_wire_byte(START_CONVERSION);		// начать преобразование	
						temperature_delay += 750;               // устанавливаем задержку на время преобразования
						ds18b20_state = 1;                      // переводим автомат в фазу получения результата преобразования
					}
					else                                        // если датчик не отвечает
					{
						Shield_display_Err();                   // выводим текст ошибки
						Buzer_Beep(SHORT_BEEP);
						temperature_delay += 2000;              // устанавливаем задержку до следующего обновления показаний температуры
						ds18b20_state = 0;
					}
				}					
				else if (ds18b20_state == 1)                    // если это фаза получения получения результат преобразования	
				{			
					one_wire_state = Reset_1_wire();		    // повторная инициализация обмена (Reset-Presence)
					if (one_wire_state == 1)                    // если датчик живой
					{
						Send_1_wire_byte(SKIP_ROM);				// пропускаем чтение адреса
						Send_1_wire_byte(READ_TEMPERATURE);		// будем читать значение температуры		
						Shield_set_display_value(Read_Temperature());// читаем, и сразу устанавливаем значение для вывода на индикатор
					}
					else                                        // если датчик не отвечает
					{
						Shield_display_Err();                   // выводим текст ошибки
						Buzer_Beep(SHORT_BEEP);
					}
					temperature_delay += 2000;                  // устанавливаем задержку до следующего обновления показаний температуры
					ds18b20_state = 0;                          // сбрасываем автомат в фазу отправки команды на начало преобразования
				}
			}
			break;
		}
		default: mode = 1;
    }							
}
//=====================================================================================================================================================
void Blink_Led_4(void)
{
    static uint16_t led_4_delay = 0;                            // если выносить переменную наружу, ее желательно инициализировать так: next_blink = t0_ctr, тогда функция сработает при первом же проходе
        
    if (t_ms - led_4_delay + 0xFF00 >= 0xFF00)
    {
		led_4_delay += 500;
        LED_4_TOGLE();
    }    
}
