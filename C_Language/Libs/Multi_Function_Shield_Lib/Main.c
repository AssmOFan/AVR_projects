/*
 * Example Main.c file for Multi_Function_Shield Library
 *
 * Created: 29.07.2018 17:00:00
 * Author : User007
 */ 

#include "MultiFunction_Shield.h"
//=====================================================================================================================================================
// Объявляем глобальные переменные и дефайны
// Все что в обработчиках прерываний - volatile
// Все что используеться только в 1 функции - static

//=====================================================================================================================================================
// Обьявляем прототипы функций

//=====================================================================================================================================================
int main(void)
{
	uint16_t key_delay = 0;										// Опрос кнопок будет производиться прямо в основном цикле программы
	uint8_t  ds18b20_mode = 0;

	Init();														// Инициализация портов и периферии

	mode = eeprom_read_byte(&eeprom_mode);                      // Восстанавливаем из памяти предыдущий режим работы
	Switch_Mode();                                              // И зажигаем соответствующий светодиод

	sei();
 
//	Главный цикл =======================================================================================================================================
	while (1)
	{
		#ifndef	USE_KEY_POLLING_INTERRUPT						// Если не используем опрос кнопок в прерывании таймера									
		key_delay--;
		if (key_delay == 0) Key_Press();						// Опрос кнопок будет производиться прямо в основном цикле программы		
		#endif

		switch(mode)
		{
			case 1:
			{
				if (adc_delay == 0)								// Если пришло время обновить показания АЦП																		 
				{	
					asm("sleep");								// Sleep and start new conversion
					Shield_set_display_value(adc_result);		// Set new ADC result for indication
					adc_delay--;								// Set new conversion delay
				}
				break;
			}
			case 2:
			{
				#ifndef	USE_INTERRUPT_4_TSOP					// Если не используем внешнее прерывание INT0 для получения кода RC5			
				uint16_t rc5_code = 0;			
				if (rc5_delay == 0) rc5_code = Get_RC5_code();	// И нет запрета на повторное считывания кода, используем функцию для получения кода RC5	
				#endif
									
				if (rc5_code != 0)
				{
					Shield_set_display_value(rc5_code & 0x07FF);// Выводим на индикатор, маскируя 2-й стартовый бит и toggle-бит
					Send_Byte((rc5_code>>8) & 0x07);			// Выводим в UART, маскируя 2-й стартовый бит и toggle-бит
					Send_Byte(rc5_code);
					rc5_code = 0;
					Buzer_Beep(50);
				}
				break;
			}
			case 3:
			{
				if (temperature_delay == 0)						// Если пришло время обновить показания температуры
				{
					uint8_t one_wire_state = 0;
					
					if (ds18b20_mode == 0)
					{							
						cli();									// Запрещаем прерывания ради точности задержек
						one_wire_state = Reset_1_wire();		// Инициализация обмена (Reset-Presence)			
						if (one_wire_state == 1)
						{
							Send_1_wire_byte(0xCC);				// Команда "skip ROM"
							Send_1_wire_byte(0x44);				// Начать преобразование	
							sei();								// Задержка на преобразование очень длинная и не строгая, разрешим прерывания
							temperature_delay = 750;			// Задержка на время преобразования
							ds18b20_mode = 1;
						}
						else
						{
							Shield_display_Err();
							Buzer_Beep(50);
							temperature_delay = 2000;			// Устанавливаем задержку до следующего обновления показаний температуры
							ds18b20_mode = 0;
						}
					}					
					else if (ds18b20_mode == 1)	
					{			
						cli();									// Запрещаем прерывания ради точности задержек
						one_wire_state = Reset_1_wire();		// Повторная инициализация обмена (Reset-Presence)
						if (one_wire_state == 1)
						{
							Send_1_wire_byte(0xCC);				// Повторная команда "skip ROM"
							Send_1_wire_byte(0xBE);				// Будем читать значение температуры		
							Shield_set_display_value(Read_Temperature());// Читаем и сразу преобразуем для вывода на индикатор
						}
						else
						{
							Shield_display_Err();
							Buzer_Beep(50);
						}
						temperature_delay = 2000;				// Устанавливаем задержку до следующего обновления показаний температуры
						ds18b20_mode = 0;
					}
					sei();
				}
				break;
			}
			default: mode = 1;
		}							
	}
}
//=====================================================================================================================================================
